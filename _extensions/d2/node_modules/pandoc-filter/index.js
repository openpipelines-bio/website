/*! pandoc-filter-node | (C) 2014 Mike Henderson <mvhenderson@tds.net> | License: MIT */
/**
 * Javascript port of https://github.com/jgm/pandocfilters
 */
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const get_stdin_1 = __importDefault(require("get-stdin"));
/**
 * Converts an action into a filter that reads a JSON-formatted pandoc
 * document from stdin, transforms it by walking the tree with the action, and
 * returns a new JSON-formatted pandoc document to stdout. The argument is a
 * function action(key, value, format, meta), where key is the type of the
 * pandoc object (e.g. 'Str', 'Para'), value is the contents of the object
 * (e.g. a string for 'Str', a list of inline elements for 'Para'), format is
 * the target output format (which will be taken for the first command
 * line argument if present), and meta is the document's metadata. If the
 * function returns None, the object to which it applies will remain
 * unchanged. If it returns an object, the object will be replaced. If it
 * returns a list, the list will be spliced in to the list to which the target
 * object belongs. (So, returning an empty list deletes the object.)
 *
 * @param  {Function} action Callback to apply to every object
 */
async function toJSONFilter(action) {
    const json = await get_stdin_1.default();
    var data = JSON.parse(json);
    var format = process.argv.length > 2 ? process.argv[2] : "";
    filter(data, action, format).then((output) => process.stdout.write(JSON.stringify(output)));
}
exports.toJSONFilter = toJSONFilter;
function isElt(x) {
    return (typeof x === "object" && x && "t" in x) || false;
}
function isEltArray(x) {
    return x.every(isElt);
}
/**
 * Walk a tree, applying an action to every object.
 * @param  {Object}   x      The object to traverse
 * @param  {Function} action Callback to apply to each item
 * @param  {String}   format Output format
 * @param  {Object}   meta   Pandoc metadata
 * @return {Object}          The modified tree
 */
async function walk(x, action, format, meta) {
    if (typeof action === "function")
        action = { single: action };
    if (Array.isArray(x)) {
        if (action.array && isEltArray(x)) {
            x = await action.array(x, format, meta);
            if (!Array.isArray(x))
                throw "impossible (just for ts)";
        }
        var array = [];
        for (const item of x) {
            if (isElt(item) && action.single) {
                var res = (await action.single(item, format, meta)) || item;
                if (Array.isArray(res)) {
                    for (const z of res) {
                        array.push(await walk(z, action, format, meta));
                    }
                }
                else {
                    array.push(await walk(res, action, format, meta));
                }
            }
            else {
                array.push(await walk(item, action, format, meta));
            }
        }
        return array;
    }
    else if (typeof x === "object" && x !== null) {
        var obj = {};
        for (const k of Object.keys(x)) {
            obj[k] = await walk(x[k], action, format, meta);
        }
        return obj;
    }
    return x;
}
exports.walk = walk;
function walkSync(x, action, format, meta) {
    if (Array.isArray(x)) {
        var array = [];
        for (const item of x) {
            if (isElt(item)) {
                var res = action(item, format, meta) || item;
                if (Array.isArray(res)) {
                    for (const z of res) {
                        array.push(walkSync(z, action, format, meta));
                    }
                }
                else {
                    array.push(walkSync(res, action, format, meta));
                }
            }
            else {
                array.push(walkSync(item, action, format, meta));
            }
        }
        return array;
    }
    else if (typeof x === "object" && x !== null) {
        var obj = {};
        for (const k of Object.keys(x)) {
            obj[k] = walkSync(x[k], action, format, meta);
        }
        return obj;
    }
    return x;
}
exports.walkSync = walkSync;
/**
 * Walks the tree x and returns concatenated string content, leaving out all
 * formatting.
 * @param  {Object} x The object to walk
 * @return {String}   JSON string
 */
function stringify(x) {
    if (!Array.isArray(x) && x.t === "MetaString")
        return x.c;
    var result = [];
    var go = function (e) {
        if (e.t === "Str")
            result.push(e.c);
        else if (e.t === "Code")
            result.push(e.c[1]);
        else if (e.t === "Math")
            result.push(e.c[1]);
        else if (e.t === "LineBreak")
            result.push(" ");
        else if (e.t === "Space")
            result.push(" ");
        else if (e.t === "SoftBreak")
            result.push(" ");
        else if (e.t === "Para")
            result.push("\n");
    };
    walkSync(x, go, "", {});
    return result.join("");
}
exports.stringify = stringify;
/**
 * Returns an attribute list, constructed from the dictionary attrs.
 * @param  {Object} attrs Attribute dictionary
 * @return {Array}        Attribute list
 */
function attributes(attrs) {
    attrs = attrs || {};
    var ident = attrs.id || "";
    var classes = attrs.classes || [];
    var keyvals = [];
    Object.keys(attrs).forEach(function (k) {
        if (k !== "classes" && k !== "id")
            keyvals.push([k, attrs[k]]);
    });
    return [ident, classes, keyvals];
}
exports.attributes = attributes;
// Utility for creating constructor functions
function elt(eltType, numargs) {
    return function (...args) {
        var len = args.length;
        if (len !== numargs)
            throw (eltType + " expects " + numargs + " arguments, but given " + len);
        return { t: eltType, c: len === 1 ? args[0] : args };
    };
}
exports.elt = elt;
/**
 * Filter the given object
 */
async function filter(data, action, format) {
    return (await walk(data, action, format, data.meta || data[0].unMeta));
}
exports.filter = filter;
/** `.meta` in the pandoc json format describes the markdown frontmatter yaml as an AST as described in
 *  https://hackage.haskell.org/package/pandoc-types-1.20/docs/Text-Pandoc-Definition.html#t:MetaValue
 *
 * this function converts a raw object to a pandoc meta AST object
 **/
function rawToMeta(e) {
    if (Array.isArray(e)) {
        return { t: "MetaList", c: e.map((x) => rawToMeta(x)) };
    }
    // warning: information loss: can't tell if it was a number or string
    if (typeof e === "string" || typeof e === "number")
        return { t: "MetaString", c: String(e) };
    if (typeof e === "object") {
        const c = fromEntries(Object.entries(e).map(([k, v]) => [k, rawToMeta(v)]));
        return { t: "MetaMap", c };
    }
    if (typeof e === "boolean")
        return { t: "MetaBool", c: e };
    throw Error(typeof e);
}
exports.rawToMeta = rawToMeta;
function metaToRaw(m) {
    if (m.t === "MetaMap") {
        return fromEntries(Object.entries(m.c).map(([k, v]) => [k, metaToRaw(v)]));
    }
    else if (m.t === "MetaList") {
        return m.c.map(metaToRaw);
    }
    else if (m.t === "MetaBool" || m.t === "MetaString") {
        return m.c;
    }
    else if (m.t === "MetaInlines" || m.t === "MetaBlocks") {
        // warning: information loss: removes formatting
        return stringify(m.c);
    }
    throw Error(`Unknown meta type ${m.t}`);
}
exports.metaToRaw = metaToRaw;
/** meta root object is a map */
function metaMapToRaw(c) {
    return metaToRaw({ t: "MetaMap", c });
}
exports.metaMapToRaw = metaMapToRaw;
/** Object.fromEntries ponyfill */
function fromEntries(iterable) {
    return [...iterable].reduce((obj, [key, val]) => {
        obj[key] = val;
        return obj;
    }, {});
}
// Constructors for block elements
exports.Plain = elt("Plain", 1);
exports.Para = elt("Para", 1);
exports.CodeBlock = elt("CodeBlock", 2);
exports.RawBlock = elt("RawBlock", 2);
exports.BlockQuote = elt("BlockQuote", 1);
exports.OrderedList = elt("OrderedList", 2);
exports.BulletList = elt("BulletList", 1);
exports.DefinitionList = elt("DefinitionList", 1);
exports.Header = elt("Header", 3);
exports.HorizontalRule = elt("HorizontalRule", 0);
exports.Table = elt("Table", 6);
exports.Div = elt("Div", 2);
exports.Null = elt("Null", 0);
// Constructors for inline elements
exports.Str = elt("Str", 1);
exports.Emph = elt("Emph", 1);
exports.Strong = elt("Strong", 1);
exports.Strikeout = elt("Strikeout", 1);
exports.Superscript = elt("Superscript", 1);
exports.Subscript = elt("Subscript", 1);
exports.SmallCaps = elt("SmallCaps", 1);
exports.Quoted = elt("Quoted", 2);
exports.Cite = elt("Cite", 2);
exports.Code = elt("Code", 2);
exports.Space = elt("Space", 0);
exports.LineBreak = elt("LineBreak", 0);
exports.Formula = elt("Math", 2); // don't conflict with js builtin Math;
exports.RawInline = elt("RawInline", 2);
exports.Link = elt("Link", 3);
exports.Image = elt("Image", 3);
exports.Note = elt("Note", 1);
exports.Span = elt("Span", 2);
// a few aliases
exports.stdio = toJSONFilter;
